---
description: 生成产品需求文档（PRD），支持产品级和完整版两种模式
argument-hint: [full（可选，输出完整技术方案）]
allowed-tools: Read, Write, Edit, Glob, Bash
---

# /dprd — 产品需求文档

## 模式判定

- 用户输入 `/dprd full` → **完整模式**（输出第 1-9 节；需求涉及 iOS 或 Android 时追加 §10）
- 用户输入 `/dprd` → **产品模式**（输出第 1-5 节）

## Step 1：接收产品描述

若用户已在对话中描述产品需求，直接进入 Step 2。否则询问：
- 要解决什么问题？
- 目标用户是谁？
- 核心场景是什么？

## Step 2：澄清需求

逐一提出聚焦问题（每次 1 个维度，给出推荐选项）：
- **核心场景**：用户最常执行的 1-3 个操作是什么？能否举一个完整的使用例子？
- **呈现粒度**（若涉及内容展示）：信息是逐条/逐段标注，还是汇总展示？
- **边界**：明确不做什么？
- **涉及端**：哪些平台/客户端？后端服务？
- **现有系统**：有哪些已有能力可以复用？
  先建立架构事实，再回答这个问题：
  - 读取 `.doc/README.md`（如存在），根据覆盖范围描述判断需要精读哪几个文件，再定向读取；同时读取 `.doc/adr/README.md`（如存在），确认有哪些已有架构决策
  - 不存在 README 时，才 glob 扫描对应目录

  整理架构事实表：

  | 新功能需要的能力 | 现有系统状态 | 结论 |
  |----------------|------------|------|
  | （示例）获取 card_id | LLM 工具结果中已包含（见 .doc/online-ai.md） | 确定性，改 Prompt 即可 |
  | （示例）Prompt 输出格式稳定 | 未验证过 | 不确定性，需要 Demo |

  > 核查目的：避免为"已经存在的能力"设计多余的工程方案。不读架构就判断，容易把确定性工作误判为需要 Demo，或把不确定性工作误判为可以直接做。
- **不确定性**：哪些工作结果不可预期？需先跑 Demo 验证；哪些有现成模式可直接集成？

  | # | 要做的事 | 结果可预期？ | 不确定性来源 | 处理方式 |
  |---|---------|------------|------------|---------|
  | 1 | 提示词质量达标 | 否 | LLM 输出存在波动 | 先跑 Demo 验证，达标后集成 |
  | 2 | CRUD 路由实现 | 是 | 有完整现成模式参考 | 直接集成（复用已有 Demo） |

  > 正例：提示词效果、LLM 输出格式 → 结果不可预期 → 必须先跑 Demo。
  > 反例：标准 REST CRUD、已有模式的 SSE 事件 → 结果可预期 → 直接集成，不需要 Demo。

完整模式追加：
- **方案倾向**：是否已有备选技术方案？偏好快速验证还是长期迭代？
- **数据约束**：核心实体有哪些？数据量级？

## Step 2.5：检查已有 PRD

读取 `.doc/prd/README.md`（如存在），确认是否已有相同或高度相关的功能 PRD：

- **已有相关 PRD** → 定向读取该 PRD，判断是更新现有文档还是新建独立 PRD
- **无相关 PRD** → 继续新建

**判断锚点：新建 vs 更新**

- 正例（更新）：README 中已有"AI 回复引用历史会议"，用户现在要补充"引用抽屉支持筛选和排序"。结论：是原功能的增强，更新现有 PRD 的 §3 功能规格，不新建。
- 反例（新建）：README 中已有"AI 回复引用历史会议"，用户现在要做"用户可以手动标注重点会议"。结论：两个功能独立，新建 PRD。
- 边界例（新建）：README 中已有"AI 回复引用历史会议（客户端解析方案）"，用户现在要做"后端推送方案替换客户端解析"。结论：虽然目标相同，但技术方案完全不同，建议新建 PRD 便于对比，或在原 PRD 中新增 §11 迁移方案。

README 不存在时跳过此步骤。

## Step 3：生成 PRD

### 产品模式（第 1-5 节）

#### 1. 概述
- **背景**：为什么要做这个功能
- **目标**：一句话描述预期成果
- **核心价值**：3 个要点（可信度/效率/体验等维度）
- **技术基线**：当前代码库与架构文档的优先级关系，格式：`以 [代码库/分支] 为准；[架构文档] 描述目标状态，冲突时以代码为准`
- **业务成功指标**：每条指标必须包含口径定义（分子/分母）和判定频率，不允许只写达标线。示范：

  | 指标 | 口径定义 | 达标线 | 判定频率 |
  |------|---------|--------|---------|
  | 引用点击率 | 点击引用编号次数 / 展示引用 UI 的消息数 | ≥ 12% | 每日滚动 7 天 |
  | citations API 延迟 | P95/P99 响应时间 | P95 ≤ 800ms | 每日 |

- **失败止损条件**：格式 `若 X 连续 N 天触发 → 执行 Y`，必须写明回滚到哪个档位或暂停哪个投入。

  > 正例：引用 API 覆盖率 < 95% 连续 3 天 → 回滚到 `write_only` 档位，暂停 Layer 3 投入。
  > 反例：单次异常不触发止损 → 以滚动窗口趋势为准，不得因单点数据执行回滚。

#### 2. 核心场景
- 用户交互流程（mermaid sequenceDiagram）
- 渲染示例 / 操作示例：用代码块展示预期效果，**每个可交互元素必须在行尾注释点击行为**，不可交互的段落注明原因。示范：

  ```
  Based on 3 related meetings        ← 可点击 → 展开抽屉，显示全部 3 条会议

  The partner expressed strong
  interest in the proposal. ①        ← ① 可点击 → 展开抽屉，仅显示第①条

  Budget allocation may need
  adjustment before proceeding. ②    ← ② 可点击 → 展开抽屉，仅显示第②条

  I've drafted the email below.      ← 任务执行段，无标记（原因：非会议来源）
  ```

#### 3. 功能规格

- 功能点表格：**必须包含"迭代层次"列，放在功能细节之前作为优先级总览**，格式如下：

  | 需求 | 迭代层次 | 说明 |
  |------|----------|------|
  | 段落级引用标注 | Layer 1（必须） | 核心业务，不可拆分 |
  | 后端引用收集器 | Layer 2（工程质量） | 不改变用户可见行为 |
  | 抽屉动画与视觉优化 | Layer 3（UI 体验） | 纯视觉升级，零业务改动 |

  > **迭代层次原则**：不是把多个 demo/版本拆成独立功能模块，而是在同一张表里标注每个需求属于哪一层。Layer 越高依赖 Layer 越低，不可倒置。

  **Layer 0（Demo 验证）**：当功能涉及 LLM/Prompt 或其他结果不可预期的能力时，Layer 1 之前必须有 Layer 0。

  | 需求 | 迭代层次 | 说明 |
  |------|----------|------|
  | Prompt 引用标记稳定性验证 | Layer 0（Demo） | 验证不确定性，后端零改动 |
  | 段落级引用标注 | Layer 1（必须） | Demo 通过后才开始 |
  | 后端引用收集器 | Layer 2（工程质量） | 不改变用户可见行为 |

  > Layer 0 的产出是"验证结论 + 通过的 Prompt/方案"，不是生产代码。Layer 0 未通过时，Layer 1 不得开始。

- **Demo 需求清单**（功能规格表中存在 Layer 0 时必须输出，放在 §3 末尾）：

  | Demo 名称 | 验证什么不确定性 | 对应 Layer 1 功能 |
  |-----------|----------------|-----------------|
  | demo-prompt-citation | Prompt 能否稳定输出引用标记格式 | 段落级引用标注 |

  > 每条 Layer 0 对应一行。Demo 名称用 kebab-case，直接作为 `/ddemo` 的输入参数。

- 每个功能点一个小节，标注所属层次
- **触发阈值表**（涉及"显示/隐藏"类需求时必须输出）：列出触发条件的量化阈值及设计依据，不允许留给实现方自由发挥。示范：

  | 引用会议数 | 横幅 | 段落引用数字 | 抽屉入口 |
  |-----------|------|------------|---------|
  | 0 | 不显示 | 不显示 | 不可用 |
  | 1 | 不显示 | 不显示 | 不可用 |
  | ≥ 2 | 显示 | 显示 | 可用 |

  > 设计依据须同行注释，如"单来源场景价值不大，≥ 2 才构成多来源综合"。

- **验收条件按层次分组**，且高层验收条件必须包含对低层的回归项（如"Layer 2 上线后，Layer 1 的所有验收测试仍然通过，无新增 skip/xfail"），让"零业务改动"等承诺变成可验证的标准，而不是口号

#### 4. 方案对比
- 对比表格（维度 × 方案 A/B/C），**每格必须是具体描述，不允许"快/慢/高/低"等单字评价**。示范：

  | 维度 | 方案 A（客户端解析） | 方案 B（后端推送） |
  |------|---------------------|-------------------|
  | 后端改动量 | 仅修改 Prompt 文本 | 新增 SSE 事件类型 + 修改对话编排器 |
  | 客户端改动量 | 流式解析器 + 逐个 API 请求 + UI 组件 | SSE 事件监听 + UI 组件（无额外 API 请求） |
  | 数据可靠性 | 依赖 AI 准确输出 ID，存在幻觉风险 | 后端校验，ID 保证有效 |
  | 渲染延迟 | 发现 ID → 发起 API → 等待响应，有加载延迟 | 数据事件先于正文到达，即时可用 |
  | 上线速度 | 快，仅需 Prompt + 客户端改动 | 慢，需后端 + 客户端协同开发 |
  | 适用阶段 | MVP / 快速验证 | 正式版 / 长期迭代 |

- 推荐策略：**必须包含推荐理由 + 切换条件**。示范：
  > 推荐先上方案 A 验证产品假设（以 ID 有效率 ≥ 90% 为达标线）；达标后迁移方案 B。两套方案的 UI 组件可复用，差异仅在数据来源。

> **方案对比置前原则**：先让读者理解"有哪些选择、为什么选这个"，再展开技术细节。

#### 5. UI 与交互规格
- 每个 UI 组件一个小节，必须包含：
  - 位置、样式、显示条件
  - **文案模板**（含变量占位符，如 `Based on {N} related meetings`）
  - **不同入口的过滤行为差异**，用表格列出每个入口的触发方式和抽屉行为。示范：

    | 入口 | 触发方式 | 抽屉过滤行为 |
    |------|---------|------------|
    | 横幅 | 点击 "Based on 3 related meetings" | 展示全部 N 条会议 |
    | 引用数字 ① | 点击段落末尾的 ① | 仅展示第①条会议 |
- 交互流程图（mermaid flowchart，展示 UI 元素间的关联）
- 单条数据结构字段表（字段、来源、说明）

### 完整模式追加（第 6-9 节）

#### 6. 技术方案
- 每个方案独立小节
- 数据流图（mermaid sequenceDiagram）
- 核心实现要点（后端/客户端分别列出关键文件和改动）
- 格式/协议定义（如有自定义标记、事件、API）
- **流式/增量场景处理**（若数据通过 SSE/WebSocket 等流式推送）：必须描述标记被截断时的 buffer 策略，用 mermaid flowchart 展示 chunk 处理逻辑
- **透传职责表**（新增字段穿越多个服务层时必须输出）：逐层标注透传/校验/消费。示范：

  | 层 | 职责 | 说明 |
  |----|------|------|
  | Gateway | 透传 | 原样转发，不读取 |
  | Core | 校验 | 验证字段合法性 |
  | Orchestrator | 透传 | 原样转发至 Executor |
  | Executor | 消费 | 读取并用于模板渲染 |

  > 判断锚点：`context.template_card_id` 穿越 Gateway/Core/Orchestrator/Executor → 必须输出此表；单层内部字段 → 不需要。

- **流式两阶段渲染语义**（SSE/WebSocket + 装饰元素并存时必须声明）：
  1. 状态变量线程归属：明确 buffer/index/map 等共享状态在哪个队列读写
  2. done 后装饰挂载策略：文本 token 实时追加渲染；引用编号、横幅等装饰元素在收到 done 事件后统一判断并挂载，不在流式阶段中途回滚

  > 判断锚点：SSE 流式 + 引用编号/横幅并存 → 采用两阶段；纯文本流式无装饰 → 不需要。

#### 7. 数据模型
- 核心数据结构（代码块，使用项目对应语言）
- 与现有数据模型的关系映射表

#### 8. 边界条件与异常处理
- 按角色/层分组（AI 行为、客户端、后端），**场景描述必须具体到触发条件，处理方式必须具体到行为**，不允许"合理处理"、"重试"等模糊描述。示范：

  **AI 行为边界**

  | 场景 | 处理 |
  |------|------|
  | AI 未触发检索工具 | 无引用标记，正常文本回复，不显示横幅 |
  | 检索到相关数据但仅 1 条 | 不显示引用 UI（阈值 ≥ 2），见 §3.4 |
  | AI 输出了不存在的 ID（方案 A） | 客户端 GET 返回 404，跳过该引用，不渲染标记 |
  | AI 遗漏了引用标记 | 该段落无引用数字，不影响其他段落 |

  **客户端边界**

  | 场景 | 处理 |
  |------|------|
  | SSE chunk 中标记被截断 | 尾部 buffer 机制，等待后续 chunk 拼接后再解析 |
  | 详情 API 请求失败（非 404） | 重试 1 次，仍失败则显示编号但标注"加载失败" |
  | 引用数据已被用户删除 | API 返回 404，跳过该引用，不渲染标记 |

#### 9. 迁移路径（迭代层次存在时必须输出）
- 当功能规格表中存在多个迭代层次（Layer 1/2/3）时，本节**必须输出**，不再是可选
- 阶段图（mermaid flowchart，每个 Layer 一个节点，标注交付物）
- 每阶段关键交付物
- **决策节点**：阶段之间必须有量化指标驱动的决策门槛（非线性路径）。示范：

  ```
  Phase 2 完成 → 收集：card_id 有效率、用户点击引用数字的频率
      → card_id 有效率 ≥ 90% 且点击率 ≥ 15% → 维持方案 A
      → 任一不达标 → 进入 Phase 3（迁移方案 B）
  ```

  > 禁止只写线性的 Phase 1 → Phase 2 → Phase 3，必须有分支和数据触发条件。

- **发布与灰度策略**（存在多档位渐进上线时必须输出）：用单枚举配置控制功能档位，避免多开关的非法组合。

  | 枚举值 | 行为描述 | 适用阶段 |
  |--------|---------|---------|
  | `off` | 完全关闭 | 紧急回滚 |
  | `write_only` | 后端写入，前端不读取 | 上线初期验证写入正确性 |
  | `api_authoritative` | 后端写入，前端通过 API 读取 | 正式能力 |

  状态约束：高档位开启前必须保证低档位已验证通过；不允许跳档。

  > 判断锚点：功能有多个渐进上线阶段且各阶段行为互斥 → 用单枚举；只有开/关两态 → 用 feature flag 即可。

- **不变量清单**（本节核心）：显式列出各迭代层次之间必须保持不变的东西，告诉开发者"什么可以动，什么不能动"：

  | 不变量 | 描述 | 层次范围 |
  |--------|------|----------|
  | 引用标记解析器 | Layer 2 上线后仍保留 [cite:] 解析逻辑作为 fallback，不可删除 | Layer 1 → Layer 2 |
  | 引用编号分配规则 | 按首次出现顺序分配，不可改为按时间或相关度排序 | Layer 1 → Layer 3 |

- **跨 PRD 一致性收口**（多 PRD 并行时必须输出）：每份 PRD 末尾附一致性清单，统一核对常量名、字段命名、ID 生成职责、验收口径。示范：

  | 约束项 | 值 | 所属 PRD |
  |--------|-----|---------|
  | CardType 枚举值 | `template` / `dynamic` | PRD-A, PRD-B |
  | block_id 格式 | `{type}_{uuid}` | PRD-A, PRD-C |
  | template_card_id 生成方 | 后端 Executor | PRD-A, PRD-B, PRD-C |

#### 10. 双端落地（涉及 iOS 或 Android 时必须输出）

##### 端侧映射表（每端一张）

**iOS**

| 需求点 | 推荐改动文件 | 说明 / 验收 |
|--------|------------|------------|
| SSE 解析器 | `ChatViewModel.swift` | Given 收到 SSE chunk When 解析 Then buffer 在串行队列读写 |
| 引用编号挂载 | `MessageRenderer.swift` | Given done 事件 When 渲染 Then 引用编号统一挂载，不回滚 |

**Android**

| 需求点 | 推荐改动文件 | 说明 / 验收 |
|--------|------------|------------|
| SSE 订阅管理 | `ChatViewModel.kt` | Given 订阅创建 When ViewModel 销毁 Then CompositeDisposable 已清理 |
| 引用编号挂载 | `MessageAdapter.kt` | Given done 事件 When 渲染 Then 引用编号统一挂载，不回滚 |

> 以上为示范行，实际按需求点填写。

##### 平台陷阱 checklist

**iOS**
- `@State` 不能安全持有 `Timer`（struct 销毁时泄漏）→ 必须用 `@StateObject class` 包装，`deinit` 中清理
- SSE 解析中的共享可变状态（如 `parsedCitations`、`nextCitationIndex`）→ 必须约束在同一串行队列读写，不可跨线程
- 数据模型必须包含 envelope 层（如 `ApiResponse<Data>`），不能只定义内层数据类型

**Android**
- `@SuppressLint("CheckResult")` 是订阅泄漏的信号 → 必须用 `CompositeDisposable` 管理
- 伪代码 `compositeDisposable.remove(/* 当前 disposable */)` 无法编译 → 需要 `var selfDisposable: Disposable? = null` 在 `subscribe` 前声明
- 数据模型必须包含 envelope 层（如 `ApiResponse<Data>`），不能只定义内层数据类型

##### Demo 阶段约束

明确不做的事（防止架构重构耦合）：
- 不重构现有网络层
- 不引入新的依赖管理框架
- 不修改与本需求无关的 ViewModel / Adapter

##### 双端验收补充

补充端侧行为的 Given/When/Then，与 §3 验收条件分组：

| 端 | Given | When | Then |
|----|-------|------|------|
| iOS | 收到 SSE done 事件 | 渲染引用编号 | 编号统一挂载，无中途回滚 |
| Android | ViewModel onCleared() | 订阅清理 | CompositeDisposable.clear() 已调用 |

## Step 4：写入文件

路径：`.doc/prd/PRD-{kebab-case-title}.md`

`.doc/prd/` 不存在时先创建目录，同时创建 `.doc/prd/README.md`。

## Step 4.5：更新 `.doc/prd/README.md`

写入 PRD 文件后，同步维护索引：

```markdown
# PRD 索引

| 文件 | 功能摘要（一句话） | Demo 需求 | 状态 |
|------|-----------------|----------|------|
| PRD-ai-meeting-citation.md | AI 回复引用历史会议记录，支持点击查看原文 | demo-prompt-citation | 草稿 |
```

**首次创建 README（兼容旧版本）**：
- 如果 `.doc/prd/` 目录存在但 README.md 不存在，先 glob 扫描 `PRD-*.md` 文件
- 读取每个 PRD 的 §1 概述（提取目标作为摘要）、§3 功能规格中的 Demo 需求清单（如有），生成完整索引表
- 状态默认为"草稿"，再追加当前新建的 PRD

**日常维护**：
- 新建 PRD → 追加一行
- 更新 PRD → 修改对应行

其他命令需要了解已有 PRD 时，只读此 README，根据功能摘要判断是否需要精读具体文件。

## Step 5：写入后提示

1. 显示生成的文件路径和模式（产品/完整）
2. 如有 Demo 需求清单：列出每项 Demo 名称，提示使用 `/ddemo {demo-名称}` 逐项生成落地方案
3. 所有 Demo 验证通过后，使用 `/dtask` 拆解集成任务
4. 产品模式下提示：如需补充技术方案细节，可使用 `/dprd full` 重新生成

## Step 6：交付前自检

写入文件后运行扫描，全部 0 命中才可交付：

```bash
rg -n '[""]' <prd-files>              # 智能引号
rg -n '/Users/|[A-Z]:\\' <prd-files>  # 绝对路径
rg -n $'\xef\xbf\xbd' <prd-files>     # 乱码字符（U+FFFD）
```

逐项确认：
- [ ] 流式方案已声明状态变量线程归属
- [ ] done 后装饰挂载策略已与文本渲染分开描述
- [ ] 示例代码无伪代码占位（如 `remove(/* 当前 disposable */)`，必须给可编译写法）
- [ ] 后端状态机行为写在后端章节，端侧章节只写消费和渲染

交付回报格式（多任务并行时）：

```
任务 #N：已完成 / 未完成
- 文件：path/to/file.md:行号
- 智能引号扫描：0 命中
- 绝对路径扫描：0 命中
- 乱码字符扫描：0 命中
```

## 不做的事

- 不自动写入 task.json（任务拆解由 `/dtask` 负责）
- 不生成代码（PRD 是需求文档，不是实现）

## 写作原则

- 结论先行：每节开头说结论，细节后面展开
- 图表优于文字：流程用 mermaid，规格用表格，示例用代码块
- 具体优于抽象：避免"合理处理"、"适当优化"等模糊表述，写具体的值和行为

## 写作门禁

- **ASCII 引号**：全文件仅允许 `"` (U+0022)，禁止 `"` `"` (U+201C/U+201D)，否则代码无法编译
- **禁止绝对路径**：只写仓库相对路径或文件名，不写 `/Users/...` 或 `C:\...`
- **Demo 阶段禁止出现**（功能规格中存在 Layer 0 时适用）：数据库 DDL（新建表、新增字段）、多服务 API 契约设计、灰度发布策略、iOS/Android 完整代码片段。以上内容在 Demo 验证通过后进入集成阶段再写。
- **Demo 阶段必须包含**：Prompt v1 内容（LLM 类功能）、测试 case 矩阵（覆盖正常路径 + 边界）、量化通过标准。
