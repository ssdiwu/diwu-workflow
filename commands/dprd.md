---
description: 生成产品需求文档（PRD），支持产品级和完整版两种模式
argument-hint: [full（可选，输出完整技术方案）]
allowed-tools: Read, Write, Edit, Glob, Bash
---

# /dprd — 产品需求文档

## 模式判定

- 用户输入 `/dprd full` → **完整模式**（输出第 1-9 节；需求涉及 iOS 或 Android 时追加 §10）
- 用户输入 `/dprd` → **产品模式**（输出第 1-5 节）

## Step 1：确认核心定位

无论上下文是否已有描述，先确认核心定位再继续。

- 若用户**尚未描述**，直接问以下三个问题（一次问完）：
  - 要解决什么问题？
  - 目标用户是谁？
  - 核心场景是什么？
- 若用户**已有描述**，复述核心定位并请用户确认，确认后进入 Step 2。

## Step 2：澄清需求

**询问规则：每次只问一个问题，等用户回答后再问下一个。**

**Q1 核心场景**：用户最常执行的 1-3 个操作是什么？能否举一个完整的使用例子？

**Q2 呈现粒度**（涉及内容展示时提问，否则跳过）：信息是逐条/逐段标注，还是汇总展示？

**Q3 边界**：明确不做什么？

**Q4 涉及端**：哪些平台/客户端？后端服务？

**Q5 现有系统**：先建立架构事实，再提问：
  - 读取 `.doc/README.md`（如存在，列格式：`| 文件 | 覆盖范围 | 最后更新(YYYY-MM-DD) |`），根据覆盖范围判断需要精读哪几个文件，再定向读取；同时读取 `.doc/adr/README.md`（如存在，列格式：`| 编号(ADR-NNN) | 标题 | 状态 | 摘要 |`）
  - 不存在 README 时，才 glob 扫描对应目录
  - 整理架构事实表（新功能需要的能力 / 现有系统状态 / 结论），核查目的：避免为已有能力设计多余工程方案

**Q6 不确定性**：哪些工作结果不可预期？需先跑 Demo 验证；哪些有现成模式可直接集成？
  > 正例：提示词效果、LLM 输出格式 → 结果不可预期 → 必须先跑 Demo。
  > 反例：标准 REST CRUD、已有模式的 SSE 事件 → 结果可预期 → 直接集成。

完整模式额外追加：

**Q7 方案倾向**：是否已有备选技术方案？偏好快速验证还是长期迭代？

**Q8 数据约束**：核心实体有哪些？数据量级？

## Step 2.5：检查已有 PRD

读取 `.doc/prd/README.md`（如存在），确认是否已有相同或高度相关的功能 PRD：

- **已有相关 PRD** → 定向读取该 PRD，判断是更新现有文档还是新建独立 PRD
- **无相关 PRD** → 继续新建

**判断锚点：新建 vs 更新**
- 正例（更新）：已有"AI 回复引用历史会议"，用户要补充"引用抽屉支持筛选"。结论：更新现有 PRD 的 §3，不新建。
- 反例（新建）：已有"AI 回复引用历史会议"，用户要做"用户手动标注重点会议"。结论：两个功能独立，新建。
- 边界例（新建）：目标相同但技术方案完全不同。结论：新建 PRD 便于对比。

## Step 3：生成 PRD

### 产品模式（第 1-5 节）

#### 1. 概述
- **背景**：为什么要做这个功能
- **目标**：一句话描述预期成果
- **核心价值**：3 个要点
- **技术基线**：`以 [代码库/分支] 为准；[架构文档] 描述目标状态，冲突时以代码为准`
- **业务成功指标**：每条指标必须包含口径定义（分子/分母）和判定频率，不允许只写达标线
- **失败止损条件**：格式 `若 X 连续 N 天触发 → 执行 Y`，必须写明回滚到哪个档位或暂停哪个投入

#### 2. 核心场景
- 用户交互流程（mermaid sequenceDiagram）
- 渲染示例 / 操作示例：用代码块展示预期效果，**每个可交互元素必须在行尾注释点击行为**，不可交互的段落注明原因

#### 3. 功能规格

- 功能点表格：**必须包含"迭代层次"列，放在功能细节之前作为优先级总览**

  | 需求 | 迭代层次 | 说明 |
  |------|----------|------|
  | （示例）段落级引用标注 | Layer 1（必须） | 核心业务，不可拆分 |

  > **迭代层次原则**：在同一张表里标注每个需求属于哪一层。Layer 越高依赖 Layer 越低，不可倒置。

  **Layer 0（Demo 验证）**：当功能涉及 LLM/Prompt 或其他结果不可预期的能力时，Layer 1 之前必须有 Layer 0。Layer 0 未通过时，Layer 1 不得开始。

- **Demo 需求清单**（功能规格表中存在 Layer 0 时必须输出，放在 §3 末尾）：

  | Demo 名称 | 验证什么不确定性 | 对应 Layer 1 功能 |
  |-----------|----------------|-----------------|

  > 每条 Layer 0 对应一行。Demo 名称用 kebab-case，直接作为 `/ddemo` 的输入参数。

- 每个功能点一个小节，标注所属层次
- **触发阈值表**（涉及"显示/隐藏"类需求时必须输出）：列出触发条件的量化阈值及设计依据，不允许留给实现方自由发挥
- **验收条件按层次分组**，高层验收条件必须包含对低层的回归项
- **每个 Layer 的验收条件必须包含至少一条边界/异常场景**（空状态、失败路径、边界值），不允许只有 happy path

#### 4. 方案对比
- 对比表格（维度 × 方案 A/B/C），**每格必须是具体描述，不允许"快/慢/高/低"等单字评价**
- 推荐策略：**必须包含推荐理由 + 切换条件**

> **方案对比置前原则**：先让读者理解"有哪些选择、为什么选这个"，再展开技术细节。

#### 5. UI 与交互规格
- 每个 UI 组件一个小节，必须包含：位置、样式、显示条件、**文案模板**（含变量占位符）、**不同入口的过滤行为差异**（用表格列出）
- 交互流程图（mermaid flowchart）
- 单条数据结构字段表（字段、来源、说明）

### 完整模式追加（第 6-9 节）

#### 6. 技术方案
- 每个方案独立小节；数据流图（mermaid sequenceDiagram）
- 核心实现要点（后端/客户端分别列出关键文件和改动）；格式/协议定义
- **流式/增量场景处理**（SSE/WebSocket）：必须描述标记被截断时的 buffer 策略
- **透传职责表**（新增字段穿越多个服务层时必须输出）：逐层标注透传/校验/消费
- **流式两阶段渲染语义**（SSE + 装饰元素并存时必须声明）：文本 token 实时追加；引用编号、横幅等装饰元素在收到 done 事件后统一挂载，不在流式阶段中途回滚

#### 7. 数据模型
- 核心数据结构（代码块，使用项目对应语言）
- 与现有数据模型的关系映射表

#### 8. 边界条件与异常处理
- 按角色/层分组（AI 行为、客户端、后端），**场景描述必须具体到触发条件，处理方式必须具体到行为**，不允许"合理处理"、"重试"等模糊描述

#### 9. 迁移路径（迭代层次存在时必须输出）
- 阶段图（mermaid flowchart，每个 Layer 一个节点，标注交付物）；每阶段关键交付物
- **决策节点**：阶段之间必须有量化指标驱动的决策门槛（非线性路径），禁止只写线性 Phase 1 → Phase 2 → Phase 3
- **发布与灰度策略**（存在多档位渐进上线时必须输出）：用单枚举配置控制功能档位，避免多开关的非法组合
- **不变量清单**：显式列出各迭代层次之间必须保持不变的东西（什么可以动，什么不能动）
- **跨 PRD 一致性收口**（多 PRD 并行时必须输出）：统一核对常量名、字段命名、ID 生成职责、验收口径

#### 10. 双端落地（涉及 iOS 或 Android 时必须输出）

##### 端侧映射表（每端一张）

`| 需求点 | 推荐改动文件 | 说明 / 验收 |`（iOS 和 Android 各一张）

##### 平台陷阱 checklist

**iOS**
- `@State` 不能安全持有 `Timer` → 必须用 `@StateObject class` 包装，`deinit` 中清理
- SSE 解析中的共享可变状态 → 必须约束在同一串行队列读写，不可跨线程
- 数据模型必须包含 envelope 层

**Android**
- `@SuppressLint("CheckResult")` 是订阅泄漏的信号 → 必须用 `CompositeDisposable` 管理
- 数据模型必须包含 envelope 层

##### Demo 阶段约束

明确不做的事：不重构现有网络层 / 不引入新的依赖管理框架 / 不修改与本需求无关的 ViewModel / Adapter

##### 双端验收补充

`| 端 | Given | When | Then |`（补充端侧行为，与 §3 验收条件分组）

## Step 4：写入文件

路径：`.doc/prd/PRD-{kebab-case-title}.md`

`.doc/prd/` 不存在时先创建目录，同时创建 `.doc/prd/README.md`。

## Step 4.5：更新 `.doc/prd/README.md`

写入 PRD 文件后，同步维护索引：

```markdown
# PRD 索引

| 文件 | 功能摘要（一句话） | Demo 需求 | 状态 |
|------|-----------------|----------|------|
```

列格式定义见 `.doc/schema.md` §PRD。

**首次创建 README（兼容旧版本）**：glob 扫描 `PRD-*.md`，读取每个 PRD 的 §1 概述和 Demo 需求清单，生成完整索引表，状态默认为 `draft`。

**日常维护**：新建 PRD → 追加一行；更新 PRD → 修改对应行。

## Step 5：写入后提示

1. 显示生成的文件路径和模式（产品/完整）
2. 如有 Demo 需求清单：列出每项 Demo 名称，提示使用 `/ddemo {demo-名称}` 逐项生成落地方案
3. 所有 Demo 验证通过后，使用 `/dtask` 拆解集成任务
4. 产品模式下提示：如需补充技术方案细节，可使用 `/dprd full` 重新生成

## Step 6：交付前自检

```bash
rg -n '[""]' <prd-files>              # 智能引号
rg -n '/Users/|[A-Z]:\\' <prd-files>  # 绝对路径
rg -n $'\xef\xbf\xbd' <prd-files>     # 乱码字符（U+FFFD）
```

逐项确认：
- [ ] 流式方案已声明状态变量线程归属
- [ ] done 后装饰挂载策略已与文本渲染分开描述
- [ ] 示例代码无伪代码占位
- [ ] 后端状态机行为写在后端章节，端侧章节只写消费和渲染

## 不做的事

- 不自动写入 task.json（任务拆解由 `/dtask` 负责）
- 不生成代码（PRD 是需求文档，不是实现）

## 写作原则

- 结论先行：每节开头说结论，细节后面展开
- 图表优于文字：流程用 mermaid，规格用表格，示例用代码块
- 具体优于抽象：避免"合理处理"、"适当优化"等模糊表述，写具体的值和行为

## 写作门禁

- **ASCII 引号**：全文件仅允许 `"` (U+0022)，禁止 `"` `"` (U+201C/U+201D)，否则代码无法编译
- **禁止绝对路径**：只写仓库相对路径或文件名，不写 `/Users/...` 或 `C:\...`
- **Demo 阶段禁止出现**（功能规格中存在 Layer 0 时适用）：数据库 DDL、多服务 API 契约设计、灰度发布策略、iOS/Android 完整代码片段
- **Demo 阶段必须包含**：Prompt v1 内容（LLM 类功能）、测试 case 矩阵（覆盖正常路径 + 边界）、量化通过标准
