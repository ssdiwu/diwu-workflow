---
description: 针对单个不确定性功能点，生成完整的 Demo PRD 落地文档
argument-hint: [Demo 名称或描述]
allowed-tools: Read, Write, Glob
---

# /ddemo — Demo 落地方案

## 适用场景

在 `/dprd` 识别出 Demo 需求后，对每个不确定性功能点单独执行。输出一份完整的 Demo PRD，指导工程师验证不确定性并形成可复用的验证资产。

小修小改（加字段、修 bug、改配置）无需执行本命令。

## Step 1：获取输入

优先级：
1. 用户在参数中提供了 Demo 名称或描述 → 直接使用
2. glob 扫描 `.doc/prd/` 目录，读取 PRD 中的 Demo 需求清单，列出让用户选择
3. 否则询问：要验证什么不确定性？

## Step 2：建立上下文

**2a. 读取现有上下文**

按以下顺序读取，不全量扫描：

1. `.doc/README.md` → 了解系统文档全貌（列格式：`| 文件 | 覆盖范围 | 最后更新 |`），根据覆盖范围描述定向读取相关文件
2. `.doc/adr/README.md` → 了解已有架构决策（列格式：`| 编号(ADR-NNN) | 标题 | 状态(Proposed|Accepted|Deprecated|Superseded) | 摘要 |`），确认有无被否决的方案
3. `.doc/prd/README.md` → 找到触发本 Demo 的原始 PRD 文件名（列格式：`| 文件 | 摘要 | demos | 状态(draft|review|approved) |`，`demos` 列是 kebab-case，直接对应 `/ddemo` 输入参数），再精读该 PRD 中关于本 Demo 的描述
4. `.doc/demo/README.md` → 确认是否已有同类 Demo 可复用（列格式：`| 文件 | 摘要 | 通过标准摘要 | 状态(pending|passed|failed) |`）

以上 README 不存在时，才 glob 扫描对应目录。

**2b. 整理最小改动点**

基于 2a，明确 Demo 验证所需的最少工作，不是完整生产方案。

## Step 3：生成 Demo PRD

### 文档结构

#### 标题与副标题

```
# demo-{kebab-case-name}

**{一句面向产品/用户的价值描述，而非技术描述}**
```

#### 用户痛点

用具体用户（有名字、有职业、有场景）描述：

- **现在的困扰**：Before 状态，具体说明用户花多少时间、遇到什么问题
- **关键价值**：3 条，After 状态下用户获得什么
- **用户真实需求**：2-3 个用户故事，格式 `"我只需要...就能..."`

#### 核心不确定性

一张对比表 + 一句话核心问题：

| | 旧思路 | 新思路（当前方案） |
|-|-------|--------------------|
| [对比维度] | [旧做法] | [新做法] |

核心不确定性：[具体描述——不是"会不会做"，是"结果能否稳定可预期"]

> 正例：「同一条 instruction，在不同 transcript 上，LLM 输出结构是否一致？」
> 反例：「能否实现这个功能」（这是工程能力问题，不是不确定性）

#### 转变效果

用对比代码块展示 Before / After：

```
❌ 优化前：[用户动作] → [不可预期的结果]
✅ 优化后：[用户动作] → [稳定可预期的结果]
```

#### 场景演示

2-3 个具体场景，每个场景必须包含：
- **用户输入**：具体文字，不是"用户输入 XXX"
- **系统输出**：完整示例内容，不是"输出类似..."
- **用户收益**：一句话

#### Demo 工作台 UI

ASCII 线框图，展示验证工具的布局和交互。至少包含两个状态：初始状态、操作后状态。

> Demo 工作台面向开发者/团队验证，不是正式产品 UI。

#### 核心验证资产

**这一节是 Demo PRD 的灵魂，篇幅占比 > 50%，不允许留空。**

根据不确定性类型选择：

- **LLM/Prompt 类**：Prompt v1 全文（可直接复制运行，不是伪代码）+ 边界 case 列表（空输入、格式异常、超长输入、模型拒绝响应等）
- **集成/数据流类**：测试 case 矩阵（输入 → 预期输出 → 验证方法），矩阵必须包含至少 2 条异常路径（如：上游返回空、字段缺失、超时）
- **第三方 API 类**：对接测试脚本 + 边界 case 列表
- **UI/交互类**：交互用例矩阵（操作序列 → 预期状态），必须包含空状态、加载失败、超时三种异常状态

> 最容易犯的错：核心验证资产里 90% 是数据库 DDL、API 契约、iOS/Android 代码 → 这是集成阶段的工作，不属于 Demo PRD。

#### 工作原理

用 mermaid sequenceDiagram 描述 Demo 的调用链路。只画 Demo 阶段，不画完整生产架构。

#### 通过标准

| 指标 | 目标 |
|------|------|
| [可量化指标名] | [具体数字，如 > 90%] |

每条指标必须可量化，不允许"效果良好"等模糊表述。

#### 边界映射

先列出所有识别到的边界场景（不限条数），再标注每条是"Demo 内"还是"Demo 外（原因）"。不允许只写"不覆盖 X"而不说明为什么，也不允许跳过此节。

#### 客户端 UI 参考（可选）

> 以下为正式客户端的交互路径，供参考，非本 Demo 的实现目标。

[ASCII 线框，仅在有必要说明产品形态时输出]

## Step 4：写入文件

路径：`.doc/demo/DEMO-{kebab-case-title}-prd.md`

`.doc/demo/` 不存在时先创建目录，同时创建 `.doc/demo/README.md`。

## Step 4.5：更新 `.doc/demo/README.md`

写入 Demo 文件后，同步维护索引：

```markdown
# Demo 索引

| 文件 | 验证什么不确定性（一句话） | 通过标准摘要 | 状态 |
|------|------------------------|------------|------|
| DEMO-prompt-citation-prd.md | Prompt 能否稳定输出引用标记格式 | 准确率 > 90%，幻觉率 < 5% | pending |
```

列格式定义见 `.doc/schema.md` §Demo。

**首次创建 README（兼容旧版本）**：
- 如果 `.doc/demo/` 目录存在但 README.md 不存在，先 glob 扫描 `DEMO-*.md` 文件
- 读取每个 Demo 的"核心不确定性"章节（作为验证内容）、"通过标准"章节（提取关键指标），生成完整索引表
- 状态默认为 `pending`，再追加当前新建的 Demo

**日常维护**：
- 新建 Demo → 追加一行
- Demo 验证通过后 → 修改状态为 `passed`

## Step 5：写入后提示

1. 显示文件路径
2. 确认核心验证资产是否完整（Prompt 全文 / 测试 case 矩阵 / 测试脚本）
3. 若有多个 Demo：提示其余 Demo 名称，可逐项继续运行 `/ddemo`
4. 所有 Demo 验证通过后，使用 `/dtask` 拆解集成任务

## 不做的事

- 不分析"哪些功能需要 Demo"（这是 `/dprd` 的职责）
- 不批量处理多个 Demo（每次只处理一个）
- 不写生产架构（数据库 DDL、多服务 API 契约、灰度策略）
- 不写 iOS/Android 完整代码片段
- 不写入 task.json（由 `/dtask` 负责）
